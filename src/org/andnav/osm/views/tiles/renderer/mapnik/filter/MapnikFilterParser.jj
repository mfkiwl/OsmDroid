/**
 * JavaCC file
 */

options {
  JDK_VERSION = "1.5";
}
PARSER_BEGIN(MapnikFilterParser)
package org.andnav.osm.views.tiles.renderer.mapnik.filter;

import java.util.Stack;
import java.io.ByteArrayInputStream;
import org.andnav.osm.views.tiles.renderer.mapnik.filter.compare.*;
import org.andnav.osm.views.tiles.renderer.mapnik.filter.maths.*;
import org.andnav.osm.views.tiles.renderer.mapnik.MapnikParameterIntValue;
import org.andnav.osm.views.tiles.renderer.mapnik.MapnikParameterDoubleValue;
import org.andnav.osm.views.tiles.renderer.mapnik.MapnikParameterStringValue;
import android.util.Log;

public class MapnikFilterParser {
	
	private static final String TAG = "MapnikFilterParser";
	private static Stack<MapnikFilter> mFilters;
	private static Stack<MapnikFilterExpression> mExpressions;
	private static MapnikFilterParser parser = null;

	public static synchronized void compile(Stack<MapnikFilter> filters, Stack<MapnikFilterExpression> expressions, String filterText) throws Exception {
		MapnikFilterParser.mFilters = filters;
		MapnikFilterParser.mExpressions = expressions;
        
        // Log.d(TAG, "Parsing String: >" + filterText + "<");
		if (parser != null)
		{
		    parser.ReInit(new ByteArrayInputStream(filterText.getBytes()));
		}
		else
		{
		    parser = new MapnikFilterParser(new ByteArrayInputStream(filterText.getBytes()));
		}
		
		try {
			parser.parseString();
		}
		catch (Exception e)
		{
			Log.e(TAG, "Parsing Failed: " + e.toString() + e.getMessage());
			throw e;
		}
	}

	public static void composeOrFilter(Stack<MapnikFilter> filters)
	{
		if (filters.size() >= 2)
		{
			MapnikFilter right = filters.pop();
			MapnikFilter left  = filters.pop();
			if (left != null && right != null)
				filters.push(new MapnikFilterLogicalOr(left, right));
		}
	}

	public static void composeAndFilter(Stack<MapnikFilter> filters)
	{
		if (filters.size() >= 2)
		{
			MapnikFilter right = filters.pop();
			MapnikFilter left  = filters.pop();
			if (left != null && right != null)
				filters.push(new MapnikFilterLogicalAnd(left, right));
		}
	}

	public static void composeNotFilter(Stack<MapnikFilter> filters)
	{
		if (filters.size() >= 1)
		{
			MapnikFilter filter  = filters.pop();
			if (filter != null)
				filters.push(new MapnikFilterLogicalNot(filter));
		}
	}

	public static void composeFilter(Stack<MapnikFilter> filters, Stack<MapnikFilterExpression> expressions, MapnikFilterCompareOp op)
	{
		if (expressions.size()>=2)
		{
			MapnikFilterExpression right = expressions.pop();
			MapnikFilterExpression left  = expressions.pop();

			if (left != null && right != null)
				filters.push(new MapnikFilterCompare(left, right, op));
		}
	}

	public static void composeExpression(Stack<MapnikFilterExpression> expressions, MapnikFilterExpressionMathsOp op)
	{
		if (expressions.size() >= 2)
		{
			MapnikFilterExpression right = expressions.pop();
			MapnikFilterExpression left  = expressions.pop();

			if (left != null && right != null)
				expressions.push(new MapnikFilterExpressionMaths(op, left, right));
		}
	}

	public static void pushInt(Stack<MapnikFilterExpression> expressions, String val)
	{
		expressions.push(new MapnikFilterLiteral(new MapnikParameterIntValue(Integer.parseInt(val))));
	}

	public static void pushDouble(Stack<MapnikFilterExpression> expressions, String val)
	{
		expressions.push(new MapnikFilterLiteral(new MapnikParameterDoubleValue(Double.parseDouble(val))));
	}

	public static void pushString(Stack<MapnikFilterExpression> expressions, String val)
	{
		expressions.push(new MapnikFilterLiteral(new MapnikParameterStringValue(val.substring(1, val.length() - 1))));
	}

	public static void pushProperty(Stack<MapnikFilterExpression> expressions, String val)
	{
		expressions.push(new MapnikFilterProperty(val.substring(1, val.length() - 1)));
	}
}
PARSER_END(MapnikFilterParser)

int parseString() : {}
{
  expression() { return 0; }
| ";"	    { return 1; }
}

SKIP :
{
 	" "
|	"\r"
|	"\t"
|	"\n"
}

TOKEN : /* and/or */
{
	< DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|	< DECIMAL_FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])+ >
|   < LETTER: [         "A"-"Z",         "a"-"z" ] >|	< STRING_LITERAL:      "'"      (   (~["\'","\\","\n","\r"])        | ("\\"            ( ["n","t","b","r","f","\\","\""]            | ["0"-"7"] ( ["0"-"7"] )?            | ["0"-"3"] ["0"-"7"] ["0"-"7"]            )          )      )*      "'" >|  	< PROPERTY: "[" (<LETTER> | "_" | ":")+ "]">
|   < AND: "and" >
|   < OR:  "or"  >
|   < NOT: "not" >
|   < LPAREN: "(" >
|   < RPAREN: ")" >
|   < EQUALS: "=" >
|   < NOTEQUAL: "<>" >
|   < GT: ">" >
|   < LT: "<" >
|   < GT_EQUAL: ">=" >
|   < LT_EQUAL: "<=" >
|   < PLUS: "+" >
|   < MINUS: "-" >
|   < MULTIPLY: "*" >
|   < DIVIDE: "/" >
}

void expression() : {}
{
	(
    	queryTerm()
	    (
	      ( <AND> queryTerm() {composeAndFilter(mFilters);}
	      | <OR> queryTerm() {composeOrFilter(mFilters);} )
	    )*
	)
}


void queryTerm() : {}
{
	(
	    operation() ( <EQUALS> operation() { composeFilter(mFilters, mExpressions, new MapnikFilterCompareOpEquals()); }
                    | <NOTEQUAL> operation() { composeFilter(mFilters, mExpressions, new MapnikFilterCompareOpNotEquals()); }
                    | <GT> operation() { composeFilter(mFilters, mExpressions, new MapnikFilterCompareOpGreaterThan()); }
                    | <LT> operation() { composeFilter(mFilters, mExpressions, new MapnikFilterCompareOpLessThan()); }
                    | <GT_EQUAL> operation() { composeFilter(mFilters, mExpressions, new MapnikFilterCompareOpGreaterThanOrEqual()); }
                    | <LT_EQUAL> operation() { composeFilter(mFilters, mExpressions, new MapnikFilterCompareOpGreaterThanOrEqual()); }
                    )
	) |
	(
	    <LPAREN> expression() <RPAREN>
	) |
    (
	    <NOT> expression() {composeNotFilter(mFilters);}
	)
}

void operation() : {}
{
	literal() ( <PLUS> literal()     { composeExpression(mExpressions, new MapnikFilterExpressionMathsOpAdd()); }
              | <MINUS> literal()    { composeExpression(mExpressions, new MapnikFilterExpressionMathsOpSub()); }
              | <MULTIPLY> literal() { composeExpression(mExpressions, new MapnikFilterExpressionMathsOpMultiply()); }
              | <DIVIDE>   literal() { composeExpression(mExpressions, new MapnikFilterExpressionMathsOpDivide()); } )*

}

void literal() : {}
{
	number() | string() | property()
}

void number() : {}
{
    <DECIMAL_FLOATING_POINT_LITERAL> { pushDouble(mExpressions, token.toString()); }
|   <DECIMAL_LITERAL> { pushInt(mExpressions, token.toString()); }
}

void string() : {}
{
	<STRING_LITERAL> { pushString(mExpressions, token.toString()); }
}

void property(): {}
{
	<PROPERTY> { pushProperty(mExpressions, token.toString()); }
}










